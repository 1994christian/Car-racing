// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: carla_protocol.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "carla_protocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* EpisodeStart_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EpisodeStart_reflection_ = NULL;
const ::google::protobuf::Descriptor* SceneInit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SceneInit_reflection_ = NULL;
const ::google::protobuf::Descriptor* Control_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Control_reflection_ = NULL;
const ::google::protobuf::Descriptor* World_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  World_reflection_ = NULL;
const ::google::protobuf::Descriptor* Scene_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Scene_reflection_ = NULL;
const ::google::protobuf::Descriptor* Scene_Projection_Matrix_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Scene_Projection_Matrix_reflection_ = NULL;
const ::google::protobuf::Descriptor* Scene_Position_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Scene_Position_reflection_ = NULL;
const ::google::protobuf::Descriptor* EpisodeReady_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EpisodeReady_reflection_ = NULL;
const ::google::protobuf::Descriptor* Reward_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Reward_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_carla_5fprotocol_2eproto() {
  protobuf_AddDesc_carla_5fprotocol_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "carla_protocol.proto");
  GOOGLE_CHECK(file != NULL);
  EpisodeStart_descriptor_ = file->message_type(0);
  static const int EpisodeStart_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EpisodeStart, start_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EpisodeStart, end_index_),
  };
  EpisodeStart_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EpisodeStart_descriptor_,
      EpisodeStart::default_instance_,
      EpisodeStart_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EpisodeStart, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EpisodeStart, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EpisodeStart));
  SceneInit_descriptor_ = file->message_type(1);
  static const int SceneInit_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SceneInit, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SceneInit, scene_),
  };
  SceneInit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SceneInit_descriptor_,
      SceneInit::default_instance_,
      SceneInit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SceneInit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SceneInit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SceneInit));
  Control_descriptor_ = file->message_type(2);
  static const int Control_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Control, steer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Control, gas_),
  };
  Control_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Control_descriptor_,
      Control::default_instance_,
      Control_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Control, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Control, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Control));
  World_descriptor_ = file->message_type(3);
  static const int World_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(World, modes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(World, scenes_),
  };
  World_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      World_descriptor_,
      World::default_instance_,
      World_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(World, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(World, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(World));
  Scene_descriptor_ = file->message_type(4);
  static const int Scene_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene, camera_matrix_),
  };
  Scene_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Scene_descriptor_,
      Scene::default_instance_,
      Scene_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Scene));
  Scene_Projection_Matrix_descriptor_ = Scene_descriptor_->nested_type(0);
  static const int Scene_Projection_Matrix_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene_Projection_Matrix, cam_param_),
  };
  Scene_Projection_Matrix_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Scene_Projection_Matrix_descriptor_,
      Scene_Projection_Matrix::default_instance_,
      Scene_Projection_Matrix_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene_Projection_Matrix, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene_Projection_Matrix, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Scene_Projection_Matrix));
  Scene_Position_descriptor_ = Scene_descriptor_->nested_type(1);
  static const int Scene_Position_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene_Position, pos_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene_Position, pos_y_),
  };
  Scene_Position_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Scene_Position_descriptor_,
      Scene_Position::default_instance_,
      Scene_Position_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene_Position, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Scene_Position, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Scene_Position));
  EpisodeReady_descriptor_ = file->message_type(5);
  static const int EpisodeReady_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EpisodeReady, ready_),
  };
  EpisodeReady_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EpisodeReady_descriptor_,
      EpisodeReady::default_instance_,
      EpisodeReady_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EpisodeReady, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EpisodeReady, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EpisodeReady));
  Reward_descriptor_ = file->message_type(6);
  static const int Reward_offsets_[16] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, player_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, player_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, collision_gen_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, collision_ped_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, collision_car_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, intersect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, inertia_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, inertia_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, inertia_z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, ori_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, ori_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, ori_z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, depth_),
  };
  Reward_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Reward_descriptor_,
      Reward::default_instance_,
      Reward_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reward, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Reward));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_carla_5fprotocol_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EpisodeStart_descriptor_, &EpisodeStart::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SceneInit_descriptor_, &SceneInit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Control_descriptor_, &Control::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    World_descriptor_, &World::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Scene_descriptor_, &Scene::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Scene_Projection_Matrix_descriptor_, &Scene_Projection_Matrix::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Scene_Position_descriptor_, &Scene_Position::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EpisodeReady_descriptor_, &EpisodeReady::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Reward_descriptor_, &Reward::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_carla_5fprotocol_2eproto() {
  delete EpisodeStart::default_instance_;
  delete EpisodeStart_reflection_;
  delete SceneInit::default_instance_;
  delete SceneInit_reflection_;
  delete Control::default_instance_;
  delete Control_reflection_;
  delete World::default_instance_;
  delete World_reflection_;
  delete Scene::default_instance_;
  delete Scene_reflection_;
  delete Scene_Projection_Matrix::default_instance_;
  delete Scene_Projection_Matrix_reflection_;
  delete Scene_Position::default_instance_;
  delete Scene_Position_reflection_;
  delete EpisodeReady::default_instance_;
  delete EpisodeReady_reflection_;
  delete Reward::default_instance_;
  delete Reward_reflection_;
}

void protobuf_AddDesc_carla_5fprotocol_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024carla_protocol.proto\"6\n\014EpisodeStart\022\023"
    "\n\013start_index\030\001 \001(\005\022\021\n\tend_index\030\002 \001(\005\"("
    "\n\tSceneInit\022\014\n\004mode\030\001 \001(\005\022\r\n\005scene\030\002 \001(\005"
    "\"%\n\007Control\022\r\n\005steer\030\001 \001(\002\022\013\n\003gas\030\002 \001(\002\""
    "&\n\005World\022\r\n\005modes\030\001 \003(\005\022\016\n\006scenes\030\002 \003(\005\""
    "\255\001\n\005Scene\022!\n\010position\030\001 \003(\0132\017.Scene.Posi"
    "tion\022/\n\rcamera_matrix\030\002 \003(\0132\030.Scene.Proj"
    "ection_Matrix\032&\n\021Projection_Matrix\022\021\n\tca"
    "m_param\030\001 \003(\002\032(\n\010Position\022\r\n\005pos_x\030\001 \002(\002"
    "\022\r\n\005pos_y\030\002 \002(\002\"\035\n\014EpisodeReady\022\r\n\005ready"
    "\030\001 \001(\010\"\252\002\n\006Reward\022\020\n\010player_x\030\001 \001(\002\022\020\n\010p"
    "layer_y\030\002 \001(\002\022\r\n\005speed\030\003 \001(\002\022\025\n\rcollisio"
    "n_gen\030\004 \001(\002\022\025\n\rcollision_ped\030\005 \001(\002\022\025\n\rco"
    "llision_car\030\006 \001(\002\022\021\n\tintersect\030\007 \001(\002\022\021\n\t"
    "inertia_x\030\010 \001(\002\022\021\n\tinertia_y\030\t \001(\002\022\021\n\tin"
    "ertia_z\030\n \001(\002\022\021\n\ttimestamp\030\013 \001(\005\022\r\n\005ori_"
    "x\030\014 \001(\002\022\r\n\005ori_y\030\r \001(\002\022\r\n\005ori_z\030\016 \001(\002\022\r\n"
    "\005image\030\017 \003(\014\022\r\n\005depth\030\020 \003(\014", 707);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "carla_protocol.proto", &protobuf_RegisterTypes);
  EpisodeStart::default_instance_ = new EpisodeStart();
  SceneInit::default_instance_ = new SceneInit();
  Control::default_instance_ = new Control();
  World::default_instance_ = new World();
  Scene::default_instance_ = new Scene();
  Scene_Projection_Matrix::default_instance_ = new Scene_Projection_Matrix();
  Scene_Position::default_instance_ = new Scene_Position();
  EpisodeReady::default_instance_ = new EpisodeReady();
  Reward::default_instance_ = new Reward();
  EpisodeStart::default_instance_->InitAsDefaultInstance();
  SceneInit::default_instance_->InitAsDefaultInstance();
  Control::default_instance_->InitAsDefaultInstance();
  World::default_instance_->InitAsDefaultInstance();
  Scene::default_instance_->InitAsDefaultInstance();
  Scene_Projection_Matrix::default_instance_->InitAsDefaultInstance();
  Scene_Position::default_instance_->InitAsDefaultInstance();
  EpisodeReady::default_instance_->InitAsDefaultInstance();
  Reward::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_carla_5fprotocol_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_carla_5fprotocol_2eproto {
  StaticDescriptorInitializer_carla_5fprotocol_2eproto() {
    protobuf_AddDesc_carla_5fprotocol_2eproto();
  }
} static_descriptor_initializer_carla_5fprotocol_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int EpisodeStart::kStartIndexFieldNumber;
const int EpisodeStart::kEndIndexFieldNumber;
#endif  // !_MSC_VER

EpisodeStart::EpisodeStart()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:EpisodeStart)
}

void EpisodeStart::InitAsDefaultInstance() {
}

EpisodeStart::EpisodeStart(const EpisodeStart& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:EpisodeStart)
}

void EpisodeStart::SharedCtor() {
  _cached_size_ = 0;
  start_index_ = 0;
  end_index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EpisodeStart::~EpisodeStart() {
  // @@protoc_insertion_point(destructor:EpisodeStart)
  SharedDtor();
}

void EpisodeStart::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EpisodeStart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EpisodeStart::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EpisodeStart_descriptor_;
}

const EpisodeStart& EpisodeStart::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_carla_5fprotocol_2eproto();
  return *default_instance_;
}

EpisodeStart* EpisodeStart::default_instance_ = NULL;

EpisodeStart* EpisodeStart::New() const {
  return new EpisodeStart;
}

void EpisodeStart::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EpisodeStart*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(start_index_, end_index_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EpisodeStart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:EpisodeStart)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 start_index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_index_)));
          set_has_start_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_end_index;
        break;
      }

      // optional int32 end_index = 2;
      case 2: {
        if (tag == 16) {
         parse_end_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &end_index_)));
          set_has_end_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:EpisodeStart)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:EpisodeStart)
  return false;
#undef DO_
}

void EpisodeStart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:EpisodeStart)
  // optional int32 start_index = 1;
  if (has_start_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->start_index(), output);
  }

  // optional int32 end_index = 2;
  if (has_end_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->end_index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:EpisodeStart)
}

::google::protobuf::uint8* EpisodeStart::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:EpisodeStart)
  // optional int32 start_index = 1;
  if (has_start_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->start_index(), target);
  }

  // optional int32 end_index = 2;
  if (has_end_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->end_index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EpisodeStart)
  return target;
}

int EpisodeStart::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 start_index = 1;
    if (has_start_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start_index());
    }

    // optional int32 end_index = 2;
    if (has_end_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->end_index());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EpisodeStart::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EpisodeStart* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EpisodeStart*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EpisodeStart::MergeFrom(const EpisodeStart& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_index()) {
      set_start_index(from.start_index());
    }
    if (from.has_end_index()) {
      set_end_index(from.end_index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EpisodeStart::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EpisodeStart::CopyFrom(const EpisodeStart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EpisodeStart::IsInitialized() const {

  return true;
}

void EpisodeStart::Swap(EpisodeStart* other) {
  if (other != this) {
    std::swap(start_index_, other->start_index_);
    std::swap(end_index_, other->end_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EpisodeStart::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EpisodeStart_descriptor_;
  metadata.reflection = EpisodeStart_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SceneInit::kModeFieldNumber;
const int SceneInit::kSceneFieldNumber;
#endif  // !_MSC_VER

SceneInit::SceneInit()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SceneInit)
}

void SceneInit::InitAsDefaultInstance() {
}

SceneInit::SceneInit(const SceneInit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SceneInit)
}

void SceneInit::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 0;
  scene_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SceneInit::~SceneInit() {
  // @@protoc_insertion_point(destructor:SceneInit)
  SharedDtor();
}

void SceneInit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SceneInit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SceneInit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SceneInit_descriptor_;
}

const SceneInit& SceneInit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_carla_5fprotocol_2eproto();
  return *default_instance_;
}

SceneInit* SceneInit::default_instance_ = NULL;

SceneInit* SceneInit::New() const {
  return new SceneInit;
}

void SceneInit::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SceneInit*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(mode_, scene_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SceneInit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SceneInit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mode_)));
          set_has_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_scene;
        break;
      }

      // optional int32 scene = 2;
      case 2: {
        if (tag == 16) {
         parse_scene:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &scene_)));
          set_has_scene();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SceneInit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SceneInit)
  return false;
#undef DO_
}

void SceneInit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SceneInit)
  // optional int32 mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mode(), output);
  }

  // optional int32 scene = 2;
  if (has_scene()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->scene(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SceneInit)
}

::google::protobuf::uint8* SceneInit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SceneInit)
  // optional int32 mode = 1;
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->mode(), target);
  }

  // optional int32 scene = 2;
  if (has_scene()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->scene(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SceneInit)
  return target;
}

int SceneInit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mode());
    }

    // optional int32 scene = 2;
    if (has_scene()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->scene());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SceneInit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SceneInit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SceneInit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SceneInit::MergeFrom(const SceneInit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_scene()) {
      set_scene(from.scene());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SceneInit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SceneInit::CopyFrom(const SceneInit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SceneInit::IsInitialized() const {

  return true;
}

void SceneInit::Swap(SceneInit* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(scene_, other->scene_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SceneInit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SceneInit_descriptor_;
  metadata.reflection = SceneInit_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Control::kSteerFieldNumber;
const int Control::kGasFieldNumber;
#endif  // !_MSC_VER

Control::Control()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Control)
}

void Control::InitAsDefaultInstance() {
}

Control::Control(const Control& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Control)
}

void Control::SharedCtor() {
  _cached_size_ = 0;
  steer_ = 0;
  gas_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Control::~Control() {
  // @@protoc_insertion_point(destructor:Control)
  SharedDtor();
}

void Control::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Control::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Control::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Control_descriptor_;
}

const Control& Control::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_carla_5fprotocol_2eproto();
  return *default_instance_;
}

Control* Control::default_instance_ = NULL;

Control* Control::New() const {
  return new Control;
}

void Control::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Control*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(steer_, gas_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Control::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Control)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float steer = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &steer_)));
          set_has_steer();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_gas;
        break;
      }

      // optional float gas = 2;
      case 2: {
        if (tag == 21) {
         parse_gas:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gas_)));
          set_has_gas();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Control)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Control)
  return false;
#undef DO_
}

void Control::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Control)
  // optional float steer = 1;
  if (has_steer()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->steer(), output);
  }

  // optional float gas = 2;
  if (has_gas()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->gas(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Control)
}

::google::protobuf::uint8* Control::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Control)
  // optional float steer = 1;
  if (has_steer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->steer(), target);
  }

  // optional float gas = 2;
  if (has_gas()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->gas(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Control)
  return target;
}

int Control::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float steer = 1;
    if (has_steer()) {
      total_size += 1 + 4;
    }

    // optional float gas = 2;
    if (has_gas()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Control::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Control* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Control*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Control::MergeFrom(const Control& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_steer()) {
      set_steer(from.steer());
    }
    if (from.has_gas()) {
      set_gas(from.gas());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Control::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Control::CopyFrom(const Control& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Control::IsInitialized() const {

  return true;
}

void Control::Swap(Control* other) {
  if (other != this) {
    std::swap(steer_, other->steer_);
    std::swap(gas_, other->gas_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Control::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Control_descriptor_;
  metadata.reflection = Control_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int World::kModesFieldNumber;
const int World::kScenesFieldNumber;
#endif  // !_MSC_VER

World::World()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:World)
}

void World::InitAsDefaultInstance() {
}

World::World(const World& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:World)
}

void World::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

World::~World() {
  // @@protoc_insertion_point(destructor:World)
  SharedDtor();
}

void World::SharedDtor() {
  if (this != default_instance_) {
  }
}

void World::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* World::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return World_descriptor_;
}

const World& World::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_carla_5fprotocol_2eproto();
  return *default_instance_;
}

World* World::default_instance_ = NULL;

World* World::New() const {
  return new World;
}

void World::Clear() {
  modes_.Clear();
  scenes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool World::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:World)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 modes = 1;
      case 1: {
        if (tag == 8) {
         parse_modes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_modes())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_modes())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_modes;
        if (input->ExpectTag(16)) goto parse_scenes;
        break;
      }

      // repeated int32 scenes = 2;
      case 2: {
        if (tag == 16) {
         parse_scenes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_scenes())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_scenes())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_scenes;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:World)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:World)
  return false;
#undef DO_
}

void World::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:World)
  // repeated int32 modes = 1;
  for (int i = 0; i < this->modes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->modes(i), output);
  }

  // repeated int32 scenes = 2;
  for (int i = 0; i < this->scenes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->scenes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:World)
}

::google::protobuf::uint8* World::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:World)
  // repeated int32 modes = 1;
  for (int i = 0; i < this->modes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(1, this->modes(i), target);
  }

  // repeated int32 scenes = 2;
  for (int i = 0; i < this->scenes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(2, this->scenes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:World)
  return target;
}

int World::ByteSize() const {
  int total_size = 0;

  // repeated int32 modes = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->modes_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->modes(i));
    }
    total_size += 1 * this->modes_size() + data_size;
  }

  // repeated int32 scenes = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->scenes_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->scenes(i));
    }
    total_size += 1 * this->scenes_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void World::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const World* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const World*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void World::MergeFrom(const World& from) {
  GOOGLE_CHECK_NE(&from, this);
  modes_.MergeFrom(from.modes_);
  scenes_.MergeFrom(from.scenes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void World::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void World::CopyFrom(const World& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool World::IsInitialized() const {

  return true;
}

void World::Swap(World* other) {
  if (other != this) {
    modes_.Swap(&other->modes_);
    scenes_.Swap(&other->scenes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata World::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = World_descriptor_;
  metadata.reflection = World_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Scene_Projection_Matrix::kCamParamFieldNumber;
#endif  // !_MSC_VER

Scene_Projection_Matrix::Scene_Projection_Matrix()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Scene.Projection_Matrix)
}

void Scene_Projection_Matrix::InitAsDefaultInstance() {
}

Scene_Projection_Matrix::Scene_Projection_Matrix(const Scene_Projection_Matrix& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Scene.Projection_Matrix)
}

void Scene_Projection_Matrix::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Scene_Projection_Matrix::~Scene_Projection_Matrix() {
  // @@protoc_insertion_point(destructor:Scene.Projection_Matrix)
  SharedDtor();
}

void Scene_Projection_Matrix::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Scene_Projection_Matrix::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Scene_Projection_Matrix::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Scene_Projection_Matrix_descriptor_;
}

const Scene_Projection_Matrix& Scene_Projection_Matrix::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_carla_5fprotocol_2eproto();
  return *default_instance_;
}

Scene_Projection_Matrix* Scene_Projection_Matrix::default_instance_ = NULL;

Scene_Projection_Matrix* Scene_Projection_Matrix::New() const {
  return new Scene_Projection_Matrix;
}

void Scene_Projection_Matrix::Clear() {
  cam_param_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Scene_Projection_Matrix::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Scene.Projection_Matrix)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float cam_param = 1;
      case 1: {
        if (tag == 13) {
         parse_cam_param:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13, input, this->mutable_cam_param())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_cam_param())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(13)) goto parse_cam_param;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Scene.Projection_Matrix)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Scene.Projection_Matrix)
  return false;
#undef DO_
}

void Scene_Projection_Matrix::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Scene.Projection_Matrix)
  // repeated float cam_param = 1;
  for (int i = 0; i < this->cam_param_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->cam_param(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Scene.Projection_Matrix)
}

::google::protobuf::uint8* Scene_Projection_Matrix::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Scene.Projection_Matrix)
  // repeated float cam_param = 1;
  for (int i = 0; i < this->cam_param_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(1, this->cam_param(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Scene.Projection_Matrix)
  return target;
}

int Scene_Projection_Matrix::ByteSize() const {
  int total_size = 0;

  // repeated float cam_param = 1;
  {
    int data_size = 0;
    data_size = 4 * this->cam_param_size();
    total_size += 1 * this->cam_param_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Scene_Projection_Matrix::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Scene_Projection_Matrix* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Scene_Projection_Matrix*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Scene_Projection_Matrix::MergeFrom(const Scene_Projection_Matrix& from) {
  GOOGLE_CHECK_NE(&from, this);
  cam_param_.MergeFrom(from.cam_param_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Scene_Projection_Matrix::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Scene_Projection_Matrix::CopyFrom(const Scene_Projection_Matrix& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Scene_Projection_Matrix::IsInitialized() const {

  return true;
}

void Scene_Projection_Matrix::Swap(Scene_Projection_Matrix* other) {
  if (other != this) {
    cam_param_.Swap(&other->cam_param_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Scene_Projection_Matrix::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Scene_Projection_Matrix_descriptor_;
  metadata.reflection = Scene_Projection_Matrix_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Scene_Position::kPosXFieldNumber;
const int Scene_Position::kPosYFieldNumber;
#endif  // !_MSC_VER

Scene_Position::Scene_Position()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Scene.Position)
}

void Scene_Position::InitAsDefaultInstance() {
}

Scene_Position::Scene_Position(const Scene_Position& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Scene.Position)
}

void Scene_Position::SharedCtor() {
  _cached_size_ = 0;
  pos_x_ = 0;
  pos_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Scene_Position::~Scene_Position() {
  // @@protoc_insertion_point(destructor:Scene.Position)
  SharedDtor();
}

void Scene_Position::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Scene_Position::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Scene_Position::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Scene_Position_descriptor_;
}

const Scene_Position& Scene_Position::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_carla_5fprotocol_2eproto();
  return *default_instance_;
}

Scene_Position* Scene_Position::default_instance_ = NULL;

Scene_Position* Scene_Position::New() const {
  return new Scene_Position;
}

void Scene_Position::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Scene_Position*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(pos_x_, pos_y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Scene_Position::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Scene.Position)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float pos_x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_pos_y;
        break;
      }

      // required float pos_y = 2;
      case 2: {
        if (tag == 21) {
         parse_pos_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pos_y_)));
          set_has_pos_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Scene.Position)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Scene.Position)
  return false;
#undef DO_
}

void Scene_Position::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Scene.Position)
  // required float pos_x = 1;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->pos_x(), output);
  }

  // required float pos_y = 2;
  if (has_pos_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->pos_y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Scene.Position)
}

::google::protobuf::uint8* Scene_Position::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Scene.Position)
  // required float pos_x = 1;
  if (has_pos_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->pos_x(), target);
  }

  // required float pos_y = 2;
  if (has_pos_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->pos_y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Scene.Position)
  return target;
}

int Scene_Position::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float pos_x = 1;
    if (has_pos_x()) {
      total_size += 1 + 4;
    }

    // required float pos_y = 2;
    if (has_pos_y()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Scene_Position::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Scene_Position* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Scene_Position*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Scene_Position::MergeFrom(const Scene_Position& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_pos_y()) {
      set_pos_y(from.pos_y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Scene_Position::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Scene_Position::CopyFrom(const Scene_Position& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Scene_Position::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Scene_Position::Swap(Scene_Position* other) {
  if (other != this) {
    std::swap(pos_x_, other->pos_x_);
    std::swap(pos_y_, other->pos_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Scene_Position::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Scene_Position_descriptor_;
  metadata.reflection = Scene_Position_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Scene::kPositionFieldNumber;
const int Scene::kCameraMatrixFieldNumber;
#endif  // !_MSC_VER

Scene::Scene()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Scene)
}

void Scene::InitAsDefaultInstance() {
}

Scene::Scene(const Scene& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Scene)
}

void Scene::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Scene::~Scene() {
  // @@protoc_insertion_point(destructor:Scene)
  SharedDtor();
}

void Scene::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Scene::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Scene::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Scene_descriptor_;
}

const Scene& Scene::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_carla_5fprotocol_2eproto();
  return *default_instance_;
}

Scene* Scene::default_instance_ = NULL;

Scene* Scene::New() const {
  return new Scene;
}

void Scene::Clear() {
  position_.Clear();
  camera_matrix_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Scene::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Scene)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Scene.Position position = 1;
      case 1: {
        if (tag == 10) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_position;
        if (input->ExpectTag(18)) goto parse_camera_matrix;
        break;
      }

      // repeated .Scene.Projection_Matrix camera_matrix = 2;
      case 2: {
        if (tag == 18) {
         parse_camera_matrix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_camera_matrix()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_camera_matrix;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Scene)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Scene)
  return false;
#undef DO_
}

void Scene::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Scene)
  // repeated .Scene.Position position = 1;
  for (int i = 0; i < this->position_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->position(i), output);
  }

  // repeated .Scene.Projection_Matrix camera_matrix = 2;
  for (int i = 0; i < this->camera_matrix_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->camera_matrix(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Scene)
}

::google::protobuf::uint8* Scene::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Scene)
  // repeated .Scene.Position position = 1;
  for (int i = 0; i < this->position_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->position(i), target);
  }

  // repeated .Scene.Projection_Matrix camera_matrix = 2;
  for (int i = 0; i < this->camera_matrix_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->camera_matrix(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Scene)
  return target;
}

int Scene::ByteSize() const {
  int total_size = 0;

  // repeated .Scene.Position position = 1;
  total_size += 1 * this->position_size();
  for (int i = 0; i < this->position_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->position(i));
  }

  // repeated .Scene.Projection_Matrix camera_matrix = 2;
  total_size += 1 * this->camera_matrix_size();
  for (int i = 0; i < this->camera_matrix_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->camera_matrix(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Scene::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Scene* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Scene*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Scene::MergeFrom(const Scene& from) {
  GOOGLE_CHECK_NE(&from, this);
  position_.MergeFrom(from.position_);
  camera_matrix_.MergeFrom(from.camera_matrix_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Scene::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Scene::CopyFrom(const Scene& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Scene::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->position())) return false;
  return true;
}

void Scene::Swap(Scene* other) {
  if (other != this) {
    position_.Swap(&other->position_);
    camera_matrix_.Swap(&other->camera_matrix_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Scene::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Scene_descriptor_;
  metadata.reflection = Scene_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EpisodeReady::kReadyFieldNumber;
#endif  // !_MSC_VER

EpisodeReady::EpisodeReady()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:EpisodeReady)
}

void EpisodeReady::InitAsDefaultInstance() {
}

EpisodeReady::EpisodeReady(const EpisodeReady& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:EpisodeReady)
}

void EpisodeReady::SharedCtor() {
  _cached_size_ = 0;
  ready_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EpisodeReady::~EpisodeReady() {
  // @@protoc_insertion_point(destructor:EpisodeReady)
  SharedDtor();
}

void EpisodeReady::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EpisodeReady::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EpisodeReady::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EpisodeReady_descriptor_;
}

const EpisodeReady& EpisodeReady::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_carla_5fprotocol_2eproto();
  return *default_instance_;
}

EpisodeReady* EpisodeReady::default_instance_ = NULL;

EpisodeReady* EpisodeReady::New() const {
  return new EpisodeReady;
}

void EpisodeReady::Clear() {
  ready_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EpisodeReady::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:EpisodeReady)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool ready = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ready_)));
          set_has_ready();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:EpisodeReady)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:EpisodeReady)
  return false;
#undef DO_
}

void EpisodeReady::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:EpisodeReady)
  // optional bool ready = 1;
  if (has_ready()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->ready(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:EpisodeReady)
}

::google::protobuf::uint8* EpisodeReady::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:EpisodeReady)
  // optional bool ready = 1;
  if (has_ready()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->ready(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EpisodeReady)
  return target;
}

int EpisodeReady::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool ready = 1;
    if (has_ready()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EpisodeReady::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EpisodeReady* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EpisodeReady*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EpisodeReady::MergeFrom(const EpisodeReady& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ready()) {
      set_ready(from.ready());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EpisodeReady::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EpisodeReady::CopyFrom(const EpisodeReady& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EpisodeReady::IsInitialized() const {

  return true;
}

void EpisodeReady::Swap(EpisodeReady* other) {
  if (other != this) {
    std::swap(ready_, other->ready_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EpisodeReady::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EpisodeReady_descriptor_;
  metadata.reflection = EpisodeReady_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Reward::kPlayerXFieldNumber;
const int Reward::kPlayerYFieldNumber;
const int Reward::kSpeedFieldNumber;
const int Reward::kCollisionGenFieldNumber;
const int Reward::kCollisionPedFieldNumber;
const int Reward::kCollisionCarFieldNumber;
const int Reward::kIntersectFieldNumber;
const int Reward::kInertiaXFieldNumber;
const int Reward::kInertiaYFieldNumber;
const int Reward::kInertiaZFieldNumber;
const int Reward::kTimestampFieldNumber;
const int Reward::kOriXFieldNumber;
const int Reward::kOriYFieldNumber;
const int Reward::kOriZFieldNumber;
const int Reward::kImageFieldNumber;
const int Reward::kDepthFieldNumber;
#endif  // !_MSC_VER

Reward::Reward()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Reward)
}

void Reward::InitAsDefaultInstance() {
}

Reward::Reward(const Reward& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Reward)
}

void Reward::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  player_x_ = 0;
  player_y_ = 0;
  speed_ = 0;
  collision_gen_ = 0;
  collision_ped_ = 0;
  collision_car_ = 0;
  intersect_ = 0;
  inertia_x_ = 0;
  inertia_y_ = 0;
  inertia_z_ = 0;
  timestamp_ = 0;
  ori_x_ = 0;
  ori_y_ = 0;
  ori_z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Reward::~Reward() {
  // @@protoc_insertion_point(destructor:Reward)
  SharedDtor();
}

void Reward::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Reward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Reward::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Reward_descriptor_;
}

const Reward& Reward::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_carla_5fprotocol_2eproto();
  return *default_instance_;
}

Reward* Reward::default_instance_ = NULL;

Reward* Reward::New() const {
  return new Reward;
}

void Reward::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Reward*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(player_x_, inertia_x_);
  }
  if (_has_bits_[8 / 32] & 16128) {
    ZR_(inertia_y_, ori_z_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  image_.Clear();
  depth_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Reward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Reward)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float player_x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &player_x_)));
          set_has_player_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_player_y;
        break;
      }

      // optional float player_y = 2;
      case 2: {
        if (tag == 21) {
         parse_player_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &player_y_)));
          set_has_player_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_speed;
        break;
      }

      // optional float speed = 3;
      case 3: {
        if (tag == 29) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_collision_gen;
        break;
      }

      // optional float collision_gen = 4;
      case 4: {
        if (tag == 37) {
         parse_collision_gen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &collision_gen_)));
          set_has_collision_gen();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_collision_ped;
        break;
      }

      // optional float collision_ped = 5;
      case 5: {
        if (tag == 45) {
         parse_collision_ped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &collision_ped_)));
          set_has_collision_ped();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_collision_car;
        break;
      }

      // optional float collision_car = 6;
      case 6: {
        if (tag == 53) {
         parse_collision_car:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &collision_car_)));
          set_has_collision_car();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_intersect;
        break;
      }

      // optional float intersect = 7;
      case 7: {
        if (tag == 61) {
         parse_intersect:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &intersect_)));
          set_has_intersect();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_inertia_x;
        break;
      }

      // optional float inertia_x = 8;
      case 8: {
        if (tag == 69) {
         parse_inertia_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &inertia_x_)));
          set_has_inertia_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_inertia_y;
        break;
      }

      // optional float inertia_y = 9;
      case 9: {
        if (tag == 77) {
         parse_inertia_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &inertia_y_)));
          set_has_inertia_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_inertia_z;
        break;
      }

      // optional float inertia_z = 10;
      case 10: {
        if (tag == 85) {
         parse_inertia_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &inertia_z_)));
          set_has_inertia_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_timestamp;
        break;
      }

      // optional int32 timestamp = 11;
      case 11: {
        if (tag == 88) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(101)) goto parse_ori_x;
        break;
      }

      // optional float ori_x = 12;
      case 12: {
        if (tag == 101) {
         parse_ori_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ori_x_)));
          set_has_ori_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(109)) goto parse_ori_y;
        break;
      }

      // optional float ori_y = 13;
      case 13: {
        if (tag == 109) {
         parse_ori_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ori_y_)));
          set_has_ori_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(117)) goto parse_ori_z;
        break;
      }

      // optional float ori_z = 14;
      case 14: {
        if (tag == 117) {
         parse_ori_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ori_z_)));
          set_has_ori_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_image;
        break;
      }

      // repeated bytes image = 15;
      case 15: {
        if (tag == 122) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_image;
        if (input->ExpectTag(130)) goto parse_depth;
        break;
      }

      // repeated bytes depth = 16;
      case 16: {
        if (tag == 130) {
         parse_depth:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_depth()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_depth;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Reward)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Reward)
  return false;
#undef DO_
}

void Reward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Reward)
  // optional float player_x = 1;
  if (has_player_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->player_x(), output);
  }

  // optional float player_y = 2;
  if (has_player_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->player_y(), output);
  }

  // optional float speed = 3;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->speed(), output);
  }

  // optional float collision_gen = 4;
  if (has_collision_gen()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->collision_gen(), output);
  }

  // optional float collision_ped = 5;
  if (has_collision_ped()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->collision_ped(), output);
  }

  // optional float collision_car = 6;
  if (has_collision_car()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->collision_car(), output);
  }

  // optional float intersect = 7;
  if (has_intersect()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->intersect(), output);
  }

  // optional float inertia_x = 8;
  if (has_inertia_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->inertia_x(), output);
  }

  // optional float inertia_y = 9;
  if (has_inertia_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->inertia_y(), output);
  }

  // optional float inertia_z = 10;
  if (has_inertia_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->inertia_z(), output);
  }

  // optional int32 timestamp = 11;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->timestamp(), output);
  }

  // optional float ori_x = 12;
  if (has_ori_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->ori_x(), output);
  }

  // optional float ori_y = 13;
  if (has_ori_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->ori_y(), output);
  }

  // optional float ori_z = 14;
  if (has_ori_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->ori_z(), output);
  }

  // repeated bytes image = 15;
  for (int i = 0; i < this->image_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      15, this->image(i), output);
  }

  // repeated bytes depth = 16;
  for (int i = 0; i < this->depth_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      16, this->depth(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Reward)
}

::google::protobuf::uint8* Reward::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Reward)
  // optional float player_x = 1;
  if (has_player_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->player_x(), target);
  }

  // optional float player_y = 2;
  if (has_player_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->player_y(), target);
  }

  // optional float speed = 3;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->speed(), target);
  }

  // optional float collision_gen = 4;
  if (has_collision_gen()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->collision_gen(), target);
  }

  // optional float collision_ped = 5;
  if (has_collision_ped()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->collision_ped(), target);
  }

  // optional float collision_car = 6;
  if (has_collision_car()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->collision_car(), target);
  }

  // optional float intersect = 7;
  if (has_intersect()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->intersect(), target);
  }

  // optional float inertia_x = 8;
  if (has_inertia_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->inertia_x(), target);
  }

  // optional float inertia_y = 9;
  if (has_inertia_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->inertia_y(), target);
  }

  // optional float inertia_z = 10;
  if (has_inertia_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->inertia_z(), target);
  }

  // optional int32 timestamp = 11;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->timestamp(), target);
  }

  // optional float ori_x = 12;
  if (has_ori_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->ori_x(), target);
  }

  // optional float ori_y = 13;
  if (has_ori_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->ori_y(), target);
  }

  // optional float ori_z = 14;
  if (has_ori_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->ori_z(), target);
  }

  // repeated bytes image = 15;
  for (int i = 0; i < this->image_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(15, this->image(i), target);
  }

  // repeated bytes depth = 16;
  for (int i = 0; i < this->depth_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(16, this->depth(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Reward)
  return target;
}

int Reward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float player_x = 1;
    if (has_player_x()) {
      total_size += 1 + 4;
    }

    // optional float player_y = 2;
    if (has_player_y()) {
      total_size += 1 + 4;
    }

    // optional float speed = 3;
    if (has_speed()) {
      total_size += 1 + 4;
    }

    // optional float collision_gen = 4;
    if (has_collision_gen()) {
      total_size += 1 + 4;
    }

    // optional float collision_ped = 5;
    if (has_collision_ped()) {
      total_size += 1 + 4;
    }

    // optional float collision_car = 6;
    if (has_collision_car()) {
      total_size += 1 + 4;
    }

    // optional float intersect = 7;
    if (has_intersect()) {
      total_size += 1 + 4;
    }

    // optional float inertia_x = 8;
    if (has_inertia_x()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float inertia_y = 9;
    if (has_inertia_y()) {
      total_size += 1 + 4;
    }

    // optional float inertia_z = 10;
    if (has_inertia_z()) {
      total_size += 1 + 4;
    }

    // optional int32 timestamp = 11;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timestamp());
    }

    // optional float ori_x = 12;
    if (has_ori_x()) {
      total_size += 1 + 4;
    }

    // optional float ori_y = 13;
    if (has_ori_y()) {
      total_size += 1 + 4;
    }

    // optional float ori_z = 14;
    if (has_ori_z()) {
      total_size += 1 + 4;
    }

  }
  // repeated bytes image = 15;
  total_size += 1 * this->image_size();
  for (int i = 0; i < this->image_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->image(i));
  }

  // repeated bytes depth = 16;
  total_size += 2 * this->depth_size();
  for (int i = 0; i < this->depth_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->depth(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Reward::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Reward* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Reward*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Reward::MergeFrom(const Reward& from) {
  GOOGLE_CHECK_NE(&from, this);
  image_.MergeFrom(from.image_);
  depth_.MergeFrom(from.depth_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_x()) {
      set_player_x(from.player_x());
    }
    if (from.has_player_y()) {
      set_player_y(from.player_y());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_collision_gen()) {
      set_collision_gen(from.collision_gen());
    }
    if (from.has_collision_ped()) {
      set_collision_ped(from.collision_ped());
    }
    if (from.has_collision_car()) {
      set_collision_car(from.collision_car());
    }
    if (from.has_intersect()) {
      set_intersect(from.intersect());
    }
    if (from.has_inertia_x()) {
      set_inertia_x(from.inertia_x());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_inertia_y()) {
      set_inertia_y(from.inertia_y());
    }
    if (from.has_inertia_z()) {
      set_inertia_z(from.inertia_z());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_ori_x()) {
      set_ori_x(from.ori_x());
    }
    if (from.has_ori_y()) {
      set_ori_y(from.ori_y());
    }
    if (from.has_ori_z()) {
      set_ori_z(from.ori_z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Reward::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Reward::CopyFrom(const Reward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reward::IsInitialized() const {

  return true;
}

void Reward::Swap(Reward* other) {
  if (other != this) {
    std::swap(player_x_, other->player_x_);
    std::swap(player_y_, other->player_y_);
    std::swap(speed_, other->speed_);
    std::swap(collision_gen_, other->collision_gen_);
    std::swap(collision_ped_, other->collision_ped_);
    std::swap(collision_car_, other->collision_car_);
    std::swap(intersect_, other->intersect_);
    std::swap(inertia_x_, other->inertia_x_);
    std::swap(inertia_y_, other->inertia_y_);
    std::swap(inertia_z_, other->inertia_z_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(ori_x_, other->ori_x_);
    std::swap(ori_y_, other->ori_y_);
    std::swap(ori_z_, other->ori_z_);
    image_.Swap(&other->image_);
    depth_.Swap(&other->depth_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Reward::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Reward_descriptor_;
  metadata.reflection = Reward_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
